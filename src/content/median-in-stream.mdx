Consider the following problem:
<aside className="mt-6 rounded-md border-l-4 border-amber-400 bg-amber-50 p-4">
  <div className="mx-2">
    <strong>Problem Statement:</strong> The median is the middle value in an
    ordered integer list. If the size of the list is even, there is no middle
    value, and the median is the mean of the two middle values. Implement a
    data structure that supports the following two operations:

    <div className="mt-2"/>

    - insert(int num) adds the integer num from the data stream to the data structure.
    - median() returns the median of all elements so far.

    <div className="mt-2"/>

    Ensure that the operations are efficient for $$1 \le n \le 10^5$$ insertions and
    $$1 \le m \le 5 \cdot 10^4$$ queries. Assume that the sum of any two numbers can
    comfortably fit into a 32-bit signed integer.
  </div>
</aside>

<div className="mt-4"/>

Before diving into the problem, I think that it is worth pausing to consider a few possible
constraints or follow-ups to the problem. For example: what if we only care about the
median of the last $$k$$ elements? What if deletions need to be supported as well?
Asking questions like these beforehand can shift your perspective and often leads to
more flexible, extendable solutions.

<div className="h-5"/>

Now, to solve this problem, let's begin by black-boxing the two operations we need to
support. We don’t need to immediately know how the data structure works internally,
only what guarantees it should provide. At a high level, our black box must satisfy
two contracts:

<div className="mt-4"/>

1. insert(int num): place a new number into the structure in such a way that we can
still access the median quickly.
2. median(): return the middle value(s) of the current set of numbers in constant time.

<div className="mt-4"/>

Thinking about it this way highlights an important point: although the median is defined
in terms of a fully sorted list, we don’t actually need the entire list sorted at all
times. We only need to keep enough information to recover the middle value(s) quickly.
I think that for problem, especially, its incredibly useful to think about only what
is minimally necessary to satisfy the problem constraints.

<div className="h-5"/>

Continuing with our black-box abstraction, we must consider next what properties we
want our black box need to expose. I think that the following list encapsulates
the key properties we want:

<div className="mt-4"/>

- <b>Efficiency:</b> Insertions should not degenerate into re-sorting the entire dataset.
- <b>Balance:</b> The data structure should maintain a balance between the lower and upper
halves of the dataset to ensure quick access to the median.
- <b>Accessibility:</b> We don’t care about arbitrary lookups. We only need the “boundary”
elements where the lower and upper halves meet.

<div className="mt-4"/>

Once framed this way, the solution becomes much more apparent: instead of treating the
structure as one ordered list of elements, we can represent it as two sorted halves,
using a container for the smaller elements and a container for the larger elements.
The median then sits in the middle where the two halves meet. Here's an illustration
to enforce the idea:

<div className="flex justify-center mt-6">
  <img
    src="/median.png"
    alt="Diagram of median in even and odd length lists"
    width="60%"
  />
</div>
<figcaption className="prose mx-auto mt-3 text-center text-sm text-gray-600 mb-6">
  Median in odd and even length lists
</figcaption>